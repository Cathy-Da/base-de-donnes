id_texte,titre,texte_contenu
4,C++,"C++是一种被广泛使用的计算机程序设计语言。它是一种通用程式設計語言，支援多重编程范式，例如過程化程序設計、面向对象程序設計、泛型程式設計和函数式程序設計等。
比雅尼·斯特勞斯特魯普博士在贝尔实验室工作期间在20世紀80年代發明並實現了C++。起初，這種語言被稱作“C with Classes”（“包含‘類’的C語言”），作為C語言的增強版出現。随后，C++不斷增加新特性。虚函数、运算符重载、多繼承、标准模板库、异常处理、运行时类型信息、命名空間等概念逐漸納入標準草案。1998年，國際標準組織頒布了C++程序設計語言的第一個國際標準ISO/IEC 14882:1998，目前最新标准为ISO/IEC 14882:2020。ISO/IEC 14882通称ISO C++。ISO C++主要包含了核心语言和标准库的规则。尽管从核心语言到标准库都有显著不同，ISO C++直接正式（normative）引用了ISO/IEC 9899（通称ISO C），且ISO C++标准库的一部分和ISO C的标准库的API完全相同，另有很小一部分和C标准库略有差异（例如，strcat等函数提供对const类型的重载）。这使得C和C++的标准库实现常常被一并提供，在核心语言规则很大一部分兼容的情况下，进一步确保用户通常较容易把符合ISO C的源程序不经修改或经极少修改直接作为C++源程序使用，也是C++语言继C语言之后流行的一个重要原因。
作为广泛被使用的工业语言，C++存在多个流行的成熟实现：GCC、基于LLVM的Clang以及Visual C++等。这些实现同时也是成熟的C语言实现，但对C语言的支持程度不一（例如，VC++对ANSI C89之后的标准支持较不完善）。大多数流行的实现包含了编译器和C++部分标准库的实现。编译器直接提供核心语言规则的实现，而库提供ISO C++标准库的实现。这些实现中，库可能同时包含和ISO C标准库的共用实现（如VC++的msvcrt）；而另一些实现的ISO C标准库则是单独于编译器项目之外提供的，如glibc和musl。C++标准库的实现也可能支持多种编译器，如GCC的libstdc++库支持GCC的g++和LLVM Clang的clang++。这些不同的丰富组合使市面上的C++环境具有许多细节上的实现差异，因而遵循ISO C++这样的权威标准对维持可移植性显得更加重要。现今讨论的C++语言，除非另行指明，通常均指ISO C++规则定义的C++语言（虽然因为实现的差异，可能不一定是最新的正式版本）。
值得注意，和流行的误解不同，ISO C和ISO C++都从未明确要求源程序被编译（compile），而仅要求翻译（translate），因此从理论上来讲，C和C++并不一定是编译型语言。技术上，实现C和C++程序的单位是翻译单元（translation unit）。作为对比，Java语言规范中就明确要求Java程序被编译为字节码，明确存在编译单元（compilation unit）。实际上C和C++也存在REPL形式的解释器实现，如CINT和Cling。但因为传统上C和C++多以编译器实现，习惯上仍有一些混用，甚至至今仍出现在ISO C++某节标准库条款的标题 （页面存档备份，存于互联网档案馆）上。
传统上，C++语言被视为和C语言实现性能相近的语言，强调运行时的高效。根據《C++編程思想》（Thinking in C++）一書，C++與C的代码执行效率往往相差在±5%之間。


== 发展历史 ==

C++語言發展大概可以分為三個階段：第一階段從80年代到1995年。這一階段C++語言基本上是傳統類型上的面向对象語言，並且憑藉着接近C語言的效率，在工業界使用的開發語言中佔據了相當大份額；第二階段從1995年到2000年，這一階段由於標準模板庫和後來的Boost等程式庫的出現，泛型程序設計在C++中佔據了越來越多的比重。當然，同時由於Java、C#等語言的出現和硬體價格的大規模下降，C++受到了一定的衝擊；第三階段從2000年至今，由於以Loki、MPL(Boost)等程式庫為代表的產生式編程和模板元編程的出現，C++出現了發展歷史上又一個新的高峰，這些新技術的出現以及和原有技術的融合，使C++已經成為當今主流程序設計語言中最複雜的一員。
比雅尼·史特勞斯特魯普工作起於1979年的C with Classes。這個構思起源於斯特劳斯特鲁普做博士論文時的一些程式撰寫經驗。他發現Simula具備很利於大型軟體開發的特點，但Simula的執行速度太慢，無法對現實需求發揮功效；BCPL雖快得多，但它過於低階的特性，使其不適於大型軟體的開發。當斯特劳斯特鲁普開始在貝爾實驗室工作時，他有分析UNIX核心關於分散式計算的問題。回想起他的博士論文經驗，斯特劳斯特鲁普開始為C語言增強一些類似Simula的特點。之所以選擇C，是因為它適於各種用途、快速和可移植性。除了C语言和Simula之外，同時也從其它語言中取得靈感，如ALGOL 68、Ada、CLU以及ML。
剛開始時，類別、衍生類別、儲存類型檢查、內聯和缺省参数特性，都是透過Cfront引入C語言之中。
1983年，C with Classes改命名為C++（++是C语言中的增值操作符）。加入了新的特性，其中包括虛擬函式、函式名和運算子多載、參考、常數、使用者可控制的自由空間儲存區控制、改良的型別檢查，并恢复了BCPL风格的雙斜線（//）單行注释（之后C99也支持了这种注释）。
1985年，發佈第一版《C++程式設計語言》，提供一個重點的語言參考，至此還不是官方標準。1985年10月出現了第一個商業化發佈。
1989年，發佈了Release 2.0。引入了多重繼承、抽象類別、靜態成員函式、常數成員函式，以及成員保護。1990年，出版了The Annotated C++ Reference Manual。這本書後來成為標準化的基礎。稍後還引入了模板、例外處理、命名空間、新的強制类型转换，以及布林类型。
隨著C++語言的演變，也逐漸演化出相應的標準程式庫。最先加進C++標準函式庫的是串流I/O程式庫，其用以取代傳統的C函式，如printf和scanf。隨後所引入的程式庫中最重要的便是標準模板庫，簡稱STL。
多年後，一個聯合的ANSI-ISO委員會於1998年對C++標準化（ISO/IEC 14882：1998）。在官方釋出1998標準的若干年後，委員會處理缺陷報告，並於2003年發佈一個C++標準的修正版本。2005年，一份名為Library Technical Report 1（簡稱TR1）的技術報告釋出。雖然還不是官方標準的一部分，不過它所提供的幾個擴展可望成為下一版C++標準的一部分。幾乎所有目前仍在維護的C++編譯器皆已支援TR1。
目前最新的C++标准是2023年10月发布的ISO/IEC 14882:2024，又称C++23。
雖然C++本身無專利，但標準文件本身並不是免費的，尽管标准文档不是免费的，但是很容易从网络中取得，最简单的就是C++标准文档之前的最后一次草稿版本，它与标准的差别几乎只在于排版上。


=== C++名字的由來 ===
C++這個名字是Rick Mascitti於1983年中所建議的，並於1983年12月首次使用。更早以前，尚在研究階段的發展中語言曾被稱為「new C」，之後是「C with Classes」。在電腦科學中，C++仍被稱為C語言的上層結構。它最後得名於C語言中的「++」運算子（其對變數的值進行遞增）。而且在共同的命名約定中，使用「+」以表示增強的程式。斯特劳斯特鲁普說：「這個名字象徵著源自於C語言變化的自然演進」。C+是一個和C/C++無關的早期程式語言。
Rick Mascitti在1992年被非正式地問起名字的由來，他表示這是在半開玩笑中說出的。他從沒想過C++會成為這門語言的正式名字。
有一個關於C++名字的笑話是，當你使用後綴++時，附加只發生在運算之後（因此，它應該是++C，而不是C++，这个笑话是说时下某些程序员还在以使用C的方式使用C++，这通常被一些权威著作认为是不正确的）。


=== C++标准 ===
由ISO/IEC JTC1/SC22/WG21进行。已经出版的标准文档如下：


== 設計原則 ==
在《C++語言的設計和演化》（1994）中，Bjarne Stroustrup描述了他在設計C++時，所使用的一些原則。知道這些原則有助於理解C++為何會是現在這個樣子。以下總結了一些原則，詳盡的內容可參閱《C++語言的設計和演化》：

C++設計成直接的和廣泛的支援多種程式設計風格（過程化程式設計、数据抽象、物件導向程式設計、泛型程式設計）。
C++設計成給程式設計者更多的選擇，即使可能導致程式設計者選擇錯誤。
C++設計成儘可能與C相容，藉此提供一個從C到C++的平滑過渡。
C++避免平台限定或沒有普遍用途的特性。
C++不使用會帶來額外開銷的特性。
C++設計成無需複雜的程式設計環境。


== 標準程序庫 ==
1998的C++標準分為兩個部分：核心語言和C++標準程式庫；後者包含了大部分標準模板庫和C標準程式庫的稍加修改版本。存在許多不屬於標準部分的C++程式庫，且使用外部連結，程式庫甚至可以用C撰寫。
C++標準程式庫充分吸收了C標準程式庫，並佐以少許的修改，使其與C++良好的運作。另一個大型的程式庫部分，是以標準模板庫（STL）為基礎，STL於1994年2月正式成為ANSI/ISO C++。它提供了實用的工具，如容器类（如：Array和Vector），迭代器（廣義指针）提供容器以類似陣列的存取方式，以及泛型算法進行搜尋和排序的運算。此外還提供了(multi)map和(multi)set，它們都共享相似的成员函数。因此，以下成為可能，使用模板撰寫泛型算法，它可以和任何容器或在任何以迭代器定義的序列上運作。如同C，使用#include指令包含標準表頭，即可存取程式庫裡的功能。C++提供69個標準表頭，其中19個不再贊成使用。
使用標準模板庫（例如：使用std::vector或std::string來取代C風格的数组或字符数组）有助於开发更安全和更靈活的软件。
在STL在納入C++標準以前，是來自HP和後來的SGI的第三方程式庫，標準中並未稱之為「STL」，它只是標準庫中的一部分，但仍有許多人使用這個名稱，以別於其它的標準庫（輸入／輸出串流、國際化、診斷、C程式庫子集，等等）。
另外，如std::basic_string此类标准委员会添加的接口，有时也被误认为STL；实际上它们并不存在于原始的SGI STL中，在标准化后SGI STL才从标准库吸收加入其中。


== C++中的特色 ==
和C語言相比，C++引入了更多的特性，包括：复合类型（引用類型等）、const限定符和constexpr常量表达式、类型处理运算符（类型别名及auto和decltype等多种类型指示符）、C++标准库（IO库与多种容器类）与迭代器、动态内存与智能指针、函数重載、面向对象程序设计（如数据抽象、成員函数、类作用域、构造函数与析构函数、静态成员、访问控制与繼承、虚函数、抽象类与接口等）、拷贝控制、运算符重载、造型与函数风格的強制类型转换、模板与泛型编程，以及異常處理、命名空間、多继承与虚继承、运行时类型识别及嵌套类等。
C++在某些案例中（見下「與C不相容之處」），進行比C還要多的類型檢查。
以「//」起始作為註解起源自C的前身BCPL，而後被重新引入到C++。
C++的一些特性，C不久之後也採用了，包括在for循环的括号中声明，C++風格的註解（使用//符號，和inline，雖然C99定義的inline關鍵字與C++的定義不相容。不過，C99也引入了不存在於C++的特性，如：可变参数巨集，和以陣列作為參數的較佳處理；某些C++編譯器可能實作若干特性，以作為擴展，但其餘部分並不符合現存的C++特性）
一個常見的混淆其實只是一個微妙的術語問題：由於它的演化來自C，在C++中的術語对象和C語言一樣是意味著記憶體區域，而不是類別的實體，在其它絕大多數的物件導向語言也是如此。舉例來說，在C和C++中，語句int i;定義一個int型別的物件，這就是變數的值i將在指派時，所存入的記憶體區域。


=== C++语言中的const关键字 ===
const是一个C和C++语言的关键字，意思是声明一個不能改變值的变量，即只读。使用const在一定程度上可以提高程序的安全性和可靠性，也便于实现对此进行优化（如把只读对象放入ROM中）。const作为型別限定符，是型別的一部分。
C++不是第一個正式引入const类型的语言。80年代早期，Bjarne Stroustrup和Dennis Retchie讨论之后提供了在C语言中readonly/writeonly的实现机制，并在带類的C中取得了一定经验。关键字const正式引入C語言是在ANSI C89。这早于第一个C++国际标准近十年，但此时const已被C++实现普遍採用。
以下是和C语言相容的用法：

但是，const在C++中有更强大的特性。它允许在编译时确定作为真正的常量表达式。例如，

此前C语言并不支持这样的用法，直到C99允许用变量作为数组长度（需要注意的是C99中的VLA支持运行期确定数组长度，但C++从未支持）。此外，C++中，命名空间作用域的const对象的名称隐含内部链接。这意味着直接在头文件里定义const对象被多个源文件包含时，也不会重定义。
在C++11及之后的C++标准中，推荐使用拥有更严格语义的constexpr限定符来表示一个可以出现在常量表达式中的变量。const可区分为顶层const(top-level const)和底层const(low-level const)。
实际上，在语义表达方面，const更多表示为“只读”，constexpr才表示一定能在翻译时确定的常量，但实际求值仍可能在运行时进行（只有像作为声明数组大小这样确定要求常量表达式的上下文中，才会因为需要确保翻译时必须确定所需的值而进行翻译时求值）。C++20引入了更严格的consteval和constinit的语法，直接限定特定的求值必须在翻译时完成。不过，和const不同，后三者修饰声明但不是类型限定符，不参与类型声明构成复合类型，不通过类型检查实现所谓的const正确性（const correctness），也不影响利用这些特性的相关API的类型签名。
一些参照C和C++设计的语言中，也存在类似的差异。例如，C#同时具有readonly和const关键字，前者接近原始的“只读”（即最先被讨论的readonly机制和C语言中的const），而后者更接近C++的const。


== 与C不兼容之处 ==
C++有时被认为是C的超集（superset），但这並不严谨。
各个版本的ISO/IEC 14882的附录C中都指出了C++和ISO C的一些不兼容之处。
大部分的C代码可以很轻易的在C++中正确编译，但仍有少数差异，导致某些有效的C代码在C++中失效，或者在C++中有不同的行为。
最常见的差异之一是，C允许从void*隐式转换到其它的指标类型，但C++不允许。下列是有效的C代码：

但要使其在C和C++两者皆能运作，就需要使用显式转换：

另一个常见的可移植問題是，C++定义了很多的新关键字，如new和class，它们在C程式中，是可以作为识別字（例：变量名）的。
C99去除了一些不兼容之处，也新增了一些C++的特性，如//注释，以及在代码中混合使用。不过C99也纳入几个和C++冲突的新特性（如：可变长数组、原生复数类型和复合逐字常数），而C++11已经加入了兼容C99预处理器的特性。
由于C++函数和C函数通常具有不同的名字修饰和调用约定，所有在C++中呼叫的C函数，须放在extern ""C"" { /* C函数声明 */ }之內。


== C++的Hello World程序 ==
下面这个程序显示“Hello, world!”然后结束运行：

这里也可以使用using指令以避免多次声明std::——

如果使用“\n”代替以上代碼裡的“endl”，输出结果相等。

std::endl 不仅仅会在某个输出流中插入换行字符，还将执行输出流的 flush() 函数（即刷新缓冲区），而'\n'则不会。

根据ISO C++的规定，全局main函数必须返回int。
以下两种形式是合法的：

不过，在一些编译器（例如Visual C++）上，

也是合法的。但是这样的写法兼容性较差。


== 語言特性 ==


=== 运算符 ===

分為


=== 預處理器 ===
C++主要有三個編譯階段：預處理、轉譯成目的碼和連結（最後的兩個階段一般才視為真正的「編譯」）。在第一階段，預處理，會將預處理器指令替換成原始碼，然後送到下一個編譯階段。


==== 預處理器指令和巨集 ====
預處理指令的運作方式是根據使用者定義的規則，簡單的把記號字元序列置換成其它的記號字元序列。它們進行巨集置換、含入其它的檔案（由底層至高階的特性，例如包含模組／包／單元／元件）、條件式編譯和條件式含入。例如：

原始代码中出現的PI，都將會替換為3.1415926535897932384626433832795028841971693993751。另一個普遍的例子是

它將使用標準庫头文件iostream中的所有内容來替換本條預處理指令。除了以上提到的常用指令以外，還有幾個額外的預處理器指令，可以用來控制編譯流程、條件式含入或排除代碼區塊等等。

參閱預處理器和C預處理器


=== 模板 ===

模板（Template）指C++程式語言中的函式模板（function template）與類別模板（class template），這種觀念是取材自Simula的泛型程式設計。它采用typename和class两个关键字，来标识模板類別的型別参数。C++11和C++14分别引入了类型别名模板和变量模板。


=== 類別与对象 ===

在物件導向物件程式設計術語中，物件（object）是資料（data）和處理資料的指令（instructions）的聯合（association）。模擬（simulate）實際世界（real-world），物件有三種特質（characteristics）：狀態（State）、行為（Behavior）、同一性身分，並且使用訊息（message）來引發彼此的互動。類別（class）為物件的藍圖或工廠，定義了物件的抽象特質，包括物件的屬性特質和物件的行為特質，屬性的值即是物件的狀態，行為即是物件能夠做的事。
C++為類別構成式物件導向程式設計語言（class-based object-oriented programming language），類別概念具現化（reification）地作為二等公民（second-class citizen）出現在C++語言當中，在語法中明確地使用類別來做到資料抽象化、封裝、模組化、繼承、子型別多型、物件狀態的自動初始化。C++中，一個類別即為一個型別，加上封裝，一個類別即為一個抽象資料型別（Abstract Data Type，ADT），繼承、多型、模板都加強了類別的可抽象性。在C++可以使用class或struct這兩個關鍵字宣告類別（class），而使用new運算子實體化類別產生的實體（instance）即為物件，是一等公民。C/C++以資料成員（data member）表達屬性，以成員函式（member function）表達行為。
声明一个Car class：

但是仍然需要注意，严格来说，C++中对象的概念和C的对应概念接近，表示的是具有特定类型的存储，而非面向对象意义上的“对象”：一个对象不一定是类类型的。此外，C++意义上的“实例”仅指模板实例化的结果，而并不指对象。作为对比，Java的“对象”和“实例”的概念和这里的使用一致。


==== 封裝 ====
封裝（Encapsulation）是將資料和處理資料的程序（procedure）組合起來，僅對外公開接口（interface），达到信息隐藏（information hiding）的功能。封裝的優點是能減少耦合（Coupling）。C++、Java、C# 等語言定義对象都是在語法中明確地使用類別（Class）來做到封裝。
C++的類別对其成员（包括数据成员、函数成员）分为三种封装状态：

公有（public）：類別的用户可以访问、使用该類別的此种成员。
保护（protected）：该類別的衍生類別可以访问、使用该類別的此成员。外部程序代码不可以访问、使用这种成员。
私有（private）：只有類別自身的成员函数可以访问、使用该類別的此成员。
一般可以将C++類的对外接口设定为公有成员；類内部使用的数据、函数设定为私有成员；供派生自该類別的子類別使用的数据、函数设定为保护成员。


==== 繼承 ====
繼承（Inheritance）是指派生类（subclass）繼承基类（superclass），會自動取得超類別除私有特質外的全部特質，同一類別的所有實體都會自動有該類別的全部特質，做到程式碼再用（reuse）。C++只支援類別構成式繼承，雖然同一類別的所有實體都有該類別的全部特質，但是實體能夠共享的實體成員只限成員函式，類別的任何實體資料成員乃每個實體獨立一份，因此物件間並不能共享狀態，除非特質為參考型別的屬性，或使用指標來間接共享。C++支持的继承关系为：

公有繼承（public inheritance）：最常用繼承关系，含义是「is-a」關係，代表了在完全使用公有繼承的物件類別之間的层次关系（hierarchy）。
受保護繼承（protected inheritance）：基礎類別的公有或保护内容可以被衍生類別，以及由此衍生的其他類別使用。但是基礎類別对外界用户是不可见的。衍生類別的用户不能访问基礎類別的成员、不能把派生類別转换（造型）为基礎類別的指针或引用。
私有繼承（private inheritance）：基礎類別的公有或保护内容仅可以被衍生類別访问。但基礎類別对衍生類別的子類別或衍生類別的用户都是不可见的。衍生類別的子類別或衍生類別的用户都不能访问基礎類別的内容、不能把衍生類別转换为基礎類別的指针或引用。
C++支持多繼承（multiple inheritance，MI）。多繼承（multiple inheritance，MI）的優缺點一直廣為使用者所爭議，許多語言（如Java）並不支援多重繼承，而改以單一繼承和介面繼承（interface inheritance），而另一些語言则采用用單一繼承和混入（mixin）。C++通过虛繼承（Virtual Inheritance）来解決多繼承带来的一系列问题。


=== 多态 ===

除了封裝與繼承外，C++還提供了多型功能，物件導向的精神在於多态（Polymorphism），一般的多态，是指動態多态，係使用繼承和動態绑定（Dynamic Binding）實現，使用多型可建立起繼承體系（Inheritance hierarchy）。類（class）與繼承只是達成多态中的一種手段，所以稱物件導向而非類別導向。
多态又分成靜態多态（Static Polymorphism）與動態多态（Dynamic Polymorphism）。C++语言支持的動態多态必須結合繼承和动态绑定（Dynamic Binding）方式實現。靜態多态是指编译时决定的多态，包括重载和以模板（template）實現多型的方法即參數化型態（Parameterized Types），是使用巨集（macro）的“程序代码膨脹法”達到多型效果。
类型轉換（type cast）也是一種非参数化（ad hoc）多态的概念，C++提供dynamic_cast, static_cast等运算符來實作强制类型轉換（Coercion）。
運算元重載（operator overloading）或函式重載（function overloading）也算是多型的概念。


== 分析和處理C++原始代碼 ==
C/Java/C#都可以用某種 LR剖析器（或其變形）分析文法，但C++是個著名的例外：请看下面的代码。

上面的table1显然是一个字符串的二维数组，而table2则未必能通过编译：如果严格遵循LR分析过程，串 >> 会被解释为右移运算符而非两个代表模板参数表结束的右尖括号，因此出现编译错误，必须以table1的方式用空格区分。(在C++11发布之后，特别规定了当处理模板时，>>被优先视为两个>，所以table1和table2均可通过编译.)


== 争议 ==
「在這12年裡，C++使用者人數大約每七個月半增加一倍」是許多C++相關文件必引的一段話；然而，時至今日新語言層出不窮，使用者人數已不太可能以如此速度增長。分析機構EvansData定期對開發人員展開調查，其資料顯示，以C++為工具的開發人員在整個開發界所佔的比例由1998年春天的76%下降至2004年秋的46%。
一部分Unix/C程序员对C++语言深恶痛绝，他们批评的理由如下：

STL以非常丑陋的方式封装了各种数据结构和算法，写出来的代码难以理解、不美观。
C++编译器复杂和不可靠，不适合构建人命关天类型的程序。
Ian Joyner认为面向对象技术徒增学习成本，不如面向过程的C语言简单容易使用，尤其是在系统软件的构建上。
概括說來UNIX程式設計師批評C++主要是由於UNIX社群與C++社群的文化差異。
Linux之父林纳斯·托瓦兹曾经多次炮轰C++。图灵奖得主尼克劳斯·维尔特也曾经批评C++语言太复杂、语法语义模糊，是“拙劣工程学”的成果。
事实上，对于C++语言的批评并不只来源于Unix/Unix-Like系统下的程序员。就像C++语言本身是一个跨平台的语言一样，对C++的批评并不局限于Unix/Unix-Like系统用户。


== 參閱 ==

《C++程式語言》（The C++ Programming Language）
比较Java和C++
C++託管擴展
C++/CLI
Boost C++ Libraries
Objective-C ，另一個以C語言添加物件導向設計的程式語言


== 参考文献 ==


== 延伸阅读 ==
Josuttis, Nicolai M. The C++ Standard Library, A Tutorial and Reference Second. Addison-Wesley. 2012. ISBN 0-321-62321-5. 
Lippman, Stanley B.; Lajoie, Josée; Moo, Barbara E. C++ Primer Fifth. Addison-Wesley. 2011. ISBN 0-321-71411-3. 
[美] Stanley B. Lippman; [美] Josée Lajoie; [美] Barbara E. Moo. C++ Primer(中文版)(第5版). 由王刚; 杨巨峰翻译. 电子工业出版社. 2013-09-01. ISBN 9787121155352 （中文（中国大陆））. 
Meyers, Scott. Effective C++ Third. Addison-Wesley. 2005. ISBN 0-321-33487-6. 
Meyers, Scott. Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library. Addison-Wesley. 2001. 
Stroustrup, Bjarne. The C++ Programming Language Fourth ed. Addison-Wesley. 2013. ISBN 978-0-321-56384-2.  引文格式1维护：冗余文本 (link)
Stroustrup, Bjarne. The Design and Evolution of C++. Addison-Wesley. 1994. ISBN 0-201-54330-3. 
Stroustrup, Bjarne. Programming Principles and Practice Using C++ Second ed. Addison-Wesley. 2014. ISBN 978-0-321-99278-9.  引文格式1维护：冗余文本 (link)
Vandevoorde, David; Josuttis, Nicolai M. C++ Templates: The complete Guide. Addison-Wesley. 2003. ISBN 0-201-73484-2. 


== 外部連結 ==

JTC1/SC22/WG21（页面存档备份，存于互联网档案馆） - The C++ Standards Committee （英文）
C和C++资源的最终列表（页面存档备份，存于互联网档案馆）
C++教學 （页面存档备份，存于互联网档案馆）
C/C++参考手册（中文） （页面存档备份，存于互联网档案馆）"
